/*
Diffie-Hellman Key Exchange with Authentication and Secrecy Guarantees
To make authentication pass for both parties, we must implement Strong Binding.
This means the signature must bind the identities of the participants to the specific 
session's ephemeral values ​​(the Diffie-Hellman shares).
Without this binding, the protocol is vulnerable to Identity Misbinding or Man-in-the-Middle attacks 
because a signature on just G_B doesn't prove that B was talking to A.
- Mutual Signatures: Both A and B must sign the exchange.
- Bind the Shares: The signature must cover both G_A and G_B.
- Bind the Identities: Include the public keys (or names) inside the signature.
- Mutual Verification: Both sides must use the verify function.
*/

theory dh_auth_and_secrecy_hold

begin

builtins: diffie-hellman, symmetric-encryption, asymmetric-encryption, signing

functions:
    checksign/2

equations:
    checksign(sign(m, sk), pk(sk)) = m

#include "headers.splib"

heuristic:s
/*
symmetric-encryption: 
It models symmetric encryption scheme. 
It defines the funciton symbols senc/2 and sdec/2 with the equation sdec(senc(m, k), k) = m.

asymmetric-encryption: 
It models asymmetric encryption scheme. 
It defines the function symbols aenc/2 and adec/2 with the equation adec(aenc(m, pk), sk) = m.

signing: 
It models digital signature scheme. 
It defines the function symbols pk/1, sign/2 and verify/3 with the equation verify(sign(m, sk),m, pk(sk)) = true.
*/

let clientA(~skA, pkA, pkB) = 
    new ~a;
    let G_A = 'g'^(~a) in
    let m1 = G_A in
    out(m1);

    in(m2);
    let encrypted_payload = adec(m2, ~skA) in
    let <msgB, sigB> = encrypted_payload in
    let <G_A_in, G_B, pkB_in> = msgB in

    if (verify(sigB, msgB, pkB) = true & G_A_in = G_A) then
        let G_BA = G_B^~a in
        event AcceptsClient(G_BA);
        new ~s;
        event SecretS(~s);
        let sigA = sign(<G_BA, pkA>, ~skA) in
        let m3 = senc(<~s, sigA>, G_BA) in
        out(m3);
        event TermClient(G_BA, pkA);
        0   
    else
        0


let serverB(~skB, pkB, pkA) = 
    in(m1);
    let G_A = m1 in

    new ~b;
    let G_B = 'g'^(~b) in
    let G_AB = G_A^~b in

    event AcceptsServer(G_AB, pkA);
    // sign identity + key
    let msgB = <G_A, G_B, pkB> in
    let sigB = sign(msgB, ~skB) in

    // Encyrpt signature under A's public key
    let m2 = aenc(<msgB, sigB>, pkA) in
    out(m2);

    in(m3);
    let <s, sigA> = sdec(m3, G_AB) in
    if verify(sigA, <G_AB, pkA>, pkA) = true then
        event TermServer(G_AB);
        0
    else
        0

#include "04properties.splib"

process:
    new ~skA; // A's long-term signing secret key
    new ~skB; // B's long-term signing secret key
    let pkA = pk(~skA) in
    let pkB = pk(~skB) in

    // Public keys are public
    out(pkA);
    out(pkB);

    (
        !clientA(~skA, pkA, pkB)
        | 
        !serverB(~skB, pkB, pkA)
    )

end