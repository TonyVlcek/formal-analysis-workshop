/*
This protocol is a classic example of a Man-in-the-Middle (MitM) vulnerability.
Authentication Fails: Even though B encrypts G_B for A ( aenc(G_B, pkA)), 
there is no binding to G_A.
An attacker can intercept A's G_A, substitute it with their own exponent G_M, 
and perform a separate DH exchange with B. 

Secrecy Fails: The session key is derived from the DH exchange (G_BA = G_B^~a).
Since authentication fails, an attacker can establish separate keys with A and B,
allowing them to decrypt and access the session key ~s that A sends encrypted under G_BA.
*/

theory example

begin

builtins: diffie-hellman, symmetric-encryption, asymmetric-encryption, signing

#include "headers.splib"

heuristic:s
/*
symmetric-encryption: 
It models symmetric encryption scheme. 
It defines the funciton symbols senc/2 and sdec/2 with the equation sdec(senc(m, k), k) = m.

asymmetric-encryption: 
It models asymmetric encryption scheme. 
It defines the function symbols aenc/2 and adec/2 with the equation adec(aenc(m, pk), sk) = m.

signing: 
It models digital signature scheme. 
It defines the function symbols pk/1, sign/2 and verify/3 with the equation verify(sign(m, sk),m, pk(sk)) = true.
*/

let clientA(~skA, pkA, pkB) = 
    new ~a;
    let G_A = 'g'^(~a) in
    let m1 = G_A in
    out(m1);

    in(m2);
    let G_B = adec(m2, ~skA) in

    let G_BA = G_B^~a in
    event AcceptsClient(G_BA);
    new ~s;
    event SecretS(~s);
    (
        leakKey(~s)
        |
        let m3 = senc(~s, G_BA) in
        out(m3);
        event TermClient(G_BA, pkA);
        0
    )


let serverB(~skB, pkB, pkA) = 
    in(m1);
    let G_A = m1 in
    new ~b;
    let G_B = 'g'^(~b) in
    let G_AB = G_A^~b in

    event AcceptsServer(G_AB, pkA);

    // Encyrpt signature under A's public key
    let m2 = aenc(G_B, pkA) in
    out(m2);

    in(m3);
    let s = sdec(m3, G_AB) in
    event TermServer(G_AB);
    0


#include "01properties.splib"

process:
    new ~skA; // A's long-term signing secret key
    new ~skB; // B's long-term signing secret key
    let pkA = pk(~skA) in
    let pkB = pk(~skB) in

    // Public keys are public
    out(pkA);
    out(pkB);

    (
        !clientA(~skA, pkA, pkB)
        | 
        !serverB(~skB, pkB, pkA)
    )

end