/*
How to make Authentication fail:
- clientA, we verify a signature on <G_B, pkB_in>, but we dont verify that B signed clientA's specific contribution ($G_A$).
Because G_A is missing from the signed message msgB, an attacker can perform a Replay Attack or a Reflection Attack:
    - The attacker intercepts B's response to any session. The attacker sends that same G_B and signature to A. 
    - A checks the signature, sees it is valid for G_B, and accepts. 
    - However, B never actually agreed to a session with this specific G_A. 
*/

theory dh_auth_fails

begin

builtins: diffie-hellman, symmetric-encryption, asymmetric-encryption, signing

#include "headers.splib"

heuristic:s
/*
symmetric-encryption: 
It models symmetric encryption scheme. 
It defines the funciton symbols senc/2 and sdec/2 with the equation sdec(senc(m, k), k) = m.

asymmetric-encryption: 
It models asymmetric encryption scheme. 
It defines the function symbols aenc/2 and adec/2 with the equation adec(aenc(m, pk), sk) = m.

signing: 
It models digital signature scheme. 
It defines the function symbols pk/1, sign/2 and verify/3 with the equation verify(sign(m, sk),m, pk(sk)) = true.
*/

let clientA(~skA, pkA, pkB) = 
    new ~a;
    let G_A = 'g'^(~a) in
    let m1 = G_A in
    out(m1);

    in(m2);
    let encrypted_payload = adec(m2, ~skA) in
    let <G_B, sigB> = encrypted_payload in

    // verify B's signature
    if (verify(sigB, G_B, pkB) = true) then
        let G_BA = G_B^~a in
        event AcceptsClient(G_BA);
        new ~s;
        event SecretS(~s);
        let m3 = senc(~s, G_BA) in
        out(m3);
        event TermClient(G_BA, pkA);
        0
    else
        0


let serverB(~skB, pkB, pkA) = 
    in(m1);
    let G_A = m1 in
    new ~b;
    let G_B = 'g'^(~b) in
    let G_AB = G_A^~b in

    event AcceptsServer(G_AB, pkA);

    let sigB = sign(G_B, ~skB) in
    // Encyrpt signature under A's public key
    let m2 = aenc(<G_B, sigB>, pkA) in
    out(m2);

    in(m3);
    let s = sdec(m3, G_AB) in
    // No verification -> Auth fails
    event TermServer(G_AB);
        0
    

#include "03properties.splib"

process:
    new ~skA; // A's long-term signing secret key
    new ~skB; // B's long-term signing secret key
    let pkA = pk(~skA) in
    let pkB = pk(~skB) in

    // Public keys are public
    out(pkA);
    out(pkB);

    (
        !clientA(~skA, pkA, pkB)
        | 
        !serverB(~skB, pkB, pkA)
    )

end